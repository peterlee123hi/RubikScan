import React, { Component } from 'react';
import ReactDOM from 'react-dom';
import Button from 'material-ui/Button';

class Camera extends Component {
    constructor(props) {
        super(props);
        this.state = {
            streaming: false,
            button: 'active'
        };

        this.processImage = this.processImage.bind(this);
        this.processImageData = this.processImageData.bind(this);
        this.rgbToHsv = this.rgbToHsv.bind(this);
    }

    processImage(ev) {
        this.setState({
            button: 'deactive'
        });

        let video = this.refs.video;
        let videoBoundingBox = video.getBoundingClientRect();
        let videoX = videoBoundingBox.x, videoY = videoBoundingBox.y;

        let canvas = document.createElement('canvas');
        canvas.width = video.videoWidth;
        canvas.height = video.videoHeight;
        let ctx = canvas.getContext('2d');
        ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

        let img = ctx.getImageData(0, 0, canvas.width, canvas.height);
        this.processImageData(img, videoX, videoY);
    }

    processImageData(img, videoX, videoY) {
        let colors = {
            'r': [255, 0, 0],
            'g': [0, 128, 0],
            'b': [0, 0, 255],
            'y': [255, 255, 0],
            'o': [255, 165, 0],
            'w': [255, 255, 255]
        }
        let colorData = []

        this.reticleBoxes.forEach((box) => {
            let reticleBox = ReactDOM.findDOMNode(this.refs[box.ref]);
            const boundingBox = reticleBox.getBoundingClientRect();
            const sX = boundingBox.x - videoX, 
                sY = boundingBox.y - videoY,
                size = boundingBox.width;
            let avgRGB = [0, 0, 0], total = 0;
            for (let x = sX; x < sX + size; x += 4) {
                for (let y = sY; y < sY + size; y += 4) {
                    let pos = (x + img.width * y) * 4, data = img.data;
                    avgRGB[0] += data[pos];
                    avgRGB[1] += data[pos + 1];
                    avgRGB[2] += data[pos + 2];
                    total++;
                }
            }
            avgRGB[0] /= total;
            avgRGB[1] /= total;
            avgRGB[2] /= total;
            console.log(this.rgbToHsv(avgRGB));

            let distance = (rgb1, rgb2) => {
                const hsv1 = this.rgbToHsv(rgb1);
                const hsv2 = this.rgbToHsv(rgb2);
                return Math.abs(hsv1[0] - hsv2[0]);
            };

            let bestDist = -1;
            let bestColor = 'r';
            for (let color in colors) {
                if (colors.hasOwnProperty(color)) {
                    const colorRGB = colors[color];
                    const dist = distance(avgRGB, colorRGB);

                    if (bestDist === -1 || dist < bestDist) {
                        bestDist = dist;
                        bestColor = color;
                    }
                }
            }
            colorData.push(bestColor);
        });

        let faceColors = [[0, 0, 0], [0, 0, 0], [0, 0, 0]];
        for (let i = 0; i < 9; i++) {
            const r = Math.floor(i % 3);
            const c = Math.floor(i / 3);
            faceColors[r][c];
        }
        console.log(faceColors[0]);
        console.log(faceColors[1]);
        console.log(faceColors[2]);
        this.props.processColorData(faceColors);
    }

    rgbToHsv(rgb) {
        let r = rgb[0] / 255;
        let g = rgb[1] / 255;
        let b = rgb[2] / 255;

        const max = Math.max(r, g, b), min = Math.min(r, g, b);
        let h;
        let s;
        let v = max;

        const d = max - min;
        s = max === 0 ? 0 : d / max;

        if (max === min) {
            h = 0; // achromatic
        } else {
            switch (max) {
                case r: h = (g - b) / d + (g < b ? 6 : 0); break;
                case g: h = (b - r) / d + 2; break;
                default: h = (r - g) / d + 4; break;
            }
            h /= 6;
        }

        return [h, s, v];
    }

    componentDidMount() {
        let video = this.refs.video;
        navigator.mediaDevices.getUserMedia({ video: true, audio: false })
            .then((stream) => {
                video.srcObject = stream;
                video.play();
            })
            .catch((err) => {
                console.log("An error occurred! " + err); 
            });

        video.addEventListener('canplay', (ev) => {
            if (!this.state.streaming) {
                this.setState({
                    streaming: true
                });
            }
        });
    }

    render() {
        this.reticleBoxes = [];
        for (let i = 1; i <= 9; i++) {
            this.reticleBoxes.push(
                <div
                className= { "Camera-reticle-box offset-" + i }
                key={ i }
                ref={ "reticle-box-" + i }
                />
            );
        }
        return <div className="Camera">
            <video
                className="Camera-video"
                ref="video">
                    Video stream not available.
            </video>
            { this.reticleBoxes }
            <Button raised disabled={this.state['button'] === 'deactive'}
                className="snap-button" 
                onClick={ this.processImage }
                color="accent">
                    Snap
            </Button>
        </div>;
    }
}

export default Camera;
